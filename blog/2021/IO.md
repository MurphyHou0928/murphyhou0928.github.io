# Ⅰ、接口综述

存储器可以直接挂在到系统总线上，外设不能直接挂在系统总线上

## 接口的基本功能
``` markdown
数据的缓冲与暂存
信号电平与类型的转换
增加信号的驱动能力
对外设进行监测、控制与管理、中断
```

## CPU与IO设备之间的信号

### ①数据信息
``` markdown
数字量
模拟量
开关量
```
### ②状态信息
``` markdown
外设->CPU
    - BUSY
    - READY
```
### ③控制信息
``` markdown
CPU->外设：控制外设的工作
```
## 接口的功能
CPU和外设之间的数据传送方式—>解决CPU与外设之间数据传输时速度不匹配问题

### ①**程序方式**
#### 无条件传送方式
``` markdown
如果CPU能够确信一个外设已经准备就绪，那就不必查询外设的状态而直接进行数据传输，这就是无条件传送方式
只适用于简单的外设的操作：开关，数码管
输入需要缓冲，输出需要锁存
```



#### 条件传送方式
``` markdown
又名“查询方式”
用条件传送方式时，CPU通过执行程序不断读取并测试外设的状态，当外设处于READY或空闲状态时，CPU输入输出指令与外设进行数据交换
在查询方式下，CPU不断读取状态字和检测状态字，如状态字表明外设并未准备好，则CPU等待，占用CPU的时间
```

### ②中断方式
``` markdown
由外设中断CPU的工作，CPU暂停执行当前程序，而去执行一个数据输入输出的程序，此程序称为中断处理子程序或中断服务子程序，中断子程序执行完后，CPU又转回来执行原来的程序
外设主动发起中断请求
CPU本身的功能：
    每条指令执行完后，如有中断请求，那么在中断允许标志位为1的情况下，CPU保留下一条指令的地址和当前的标志，转去执行中断服务子程序
多个中断源产生中断，中断优先级问题？
```

### ③DMA（直接存储器存取方式）

# Ⅱ、串行接口和串行通信

数据是一位一位进行传输的

每一位数据占用一个固定的时间长度

## 空间

``` markdown
全双工
半双工
单工
```

## 时间

``` 
异步方式：收发双方不用统一时钟进行定时
两个字符之间的传输间隔是任意的，每一个字符的前后都要用一些数位来作为分隔位
起始位：每个字符开始传送的标志，起始位采用逻辑0电平
数据位：数据位紧跟着起始位传送；由5-8个二进制位阻成，低位先传；
校验位：奇校验，偶校验，不传送校验位
停止位：表示该字符传送结束。停止位采用逻辑电平1，可选择1，1.5或2位
---------------------------------------------------------------------------------------------------------------
同步方式：收发双方采用同一个时钟信号定时
以一个固定长度的字符阻成的数据块为传输单位，每个数据块附加一个或两个同步字符，最后以校验字符结束
```

## 串行通信的传输率

``` markdown
波特率：指的单位时间内传送二进制数据的位数，单位为位/秒（bps）

发送时钟：决定数据位宽度的时钟

接收时钟：用与测定每一位输入数据位宽度的时钟

发送/接收时钟=n*波特率

- n为波特率因子，表征多少个时钟周期传输一个bit
- n=1或16或32或64
- 接收端一般n远大于1
```



# Ⅲ、8251A

## 1.基本性能

可以工作在同步或异步方式
![1](IO.assets/1.png)

## 2.基本工作原理

<img src="IO.assets/2.png" alt="2" style="zoom:80%;" />

### 七个模块

``` markdown
接收缓冲器
	从RXD引脚上接收串行数据，并按照相应的格式将串行数据转换成并行数据

接收控制电路
	对接收的数据进行检测，检测起始位，校验位，停止位等

发送缓冲器
	把来自CPU的并行数据加上相应的控制信息，然后转换成串行数据从TXD引脚发送出去

发送控制电路
	控制插入起始位，校验位，停止位，同步字符等

数据总线缓冲器
	把8251和系统总线相连，在CPU执行输入/输出指令时，游数据总线缓冲器发送和接收数据
	控制字，命令字和状态信息也通过数据总线缓冲区传输

读/写控制逻辑电路

    接收写信号 /WR，并将来自数据总线的数据和控制字写入8251A
    接收读信号 /RD，并将数据或状态字从8251A送往数据总线
    - C//D：控制/数据信号；C//D   /WR   /RD三个信号组合起来通知8251A当前读写的是数据，控制字，还是状态字
    - CLK：时钟信号
    - RESET：复位信号

调制/解调控制电路
	实现 8251A与调制/解调器的连接
```

### 8251A的发送和接收

#### 异步方式
``` markdown
接收

    在异步方式准备接收一个字符的时候，RxD就在线上检测低电平（没有检测的时候就是高电平），假如这个时候检测到了低电平，8251A就会以这个低电平作为起始位，并且启动内部定时计数器，当计数器到一半数位传输时间（比如初始设置时间脉冲为波特率的16倍），则定时器到第八个脉冲的时候，又重新对RxD进行取样，如果仍为低电平就确定是一个有效的起始位，（如果这个时候为高电平了，8251A会认为刚刚低电平是一个干扰信号，这个过程就重头开始了），8251就开始进行常规取样并进行字符装配（就是每隔一段时间对RxD进行采样）数据进入移位寄存器后（并进行去掉奇偶校验位和停止位），变成并行数据，在通过内部总线送到数据输入寄存器，同时发出RxRDY信号到CPU，表示外设的数据已经收到了，是可用的。对于少于八位的，高位自动填零

发送

    当程序把TxEn（允许发送信号）和CTS#（清除请求发送信号，不懂的朋友再仔细看看上文）后就开始发送。在发送的时候，发送器自动添加1个起始位，再按照初始化的格式添加奇偶校验位，停止位。数据及起始位，校验位，停止位总是在发送时钟的TxC下降沿时发出
```
#### 同步方式

``` markdown
接收

    其实和异步也差不多，就是RxD先进行搜索同步字符，找到第一个数据了，送到移位寄存器移位，然后和同步字符的内容进行比较，相等就是找到了，SYNRET=1；开始接收数据块，不相等就重新来（双同步也差不多，就是第一次找到了再来一次，第二次找不到重头开始找第一个字符）,如果是外同步的话，如果SYNDET=1；的时候，直接开始，RxD就不用找起始位了直接开始采样数据块。
    实现同步之后，就利用时钟信号对RxD进行数据采样，送到移位寄存器移位，然后从RxRDY引脚发出一个信号，表示已经收到了一个字符，一旦CPU读完之后，这个RxRDY=0；

发送

    发送也差不多，程序先对TxEN和CTS#初始化了，这个时候就开始发送，程序会先发1/2个同步字符，然后发送数据块，发送数据块的时候，发送器自动按初始化要求添加奇偶校验位（没有就不加）。如果8251正在发送的时候CPU来不及发送数据了（比如说遇到了中断之类的），那么就会重新发1/2个同步字符，等待CPU。满足了同步字符之间没有空隙。
```


## 3.8251A的对外信号



### 8251A和CPU之间的连接信号

![3](IO.assets/9.png)

``` markdown

片选信号

	/CS：CS#，片选信号，由M/IO#和地址译码器得到

数据信号

    - D0-D7：D0-D7        数据传输信号
    8251A的8根数据线D7-D0与8086的数据总线相连

读/写控制信号

    /RD：RD# 读信号，CPU从8251A中读信息
    /WD：WR# 写信号，CPU写入8251A

    8251只有两个端口地址，数据端口是偶地址（输入输出是一个端口），控制信息是奇地址，在8086中是用A1来区分奇偶地址的，如果A1是0，就是偶地址，A1为1就是奇地址，这刚好和C/D#对应了，所以A1脚通常连接C/D#

    | C//D    | /RD     | /WD     | 操作                   |
    |—————————|—————————|—————————|————————————————————————|
    | 0       | 0       | 1       | CPU从8251A输入数据      |
    | 0       | 1       | 0       | CPU往8251A输出数据      |
    | 1       | 0       | 1       | CPU读取8251A的状态      |
    | 1       | 1       | 0       | CPU往8251A写入控制命令  |

收发联络信号

    - TXRDY：发送准备好信号，用来通知CPU，8251A已经准备好发送一个字符

    - TxRDY：发送器准备好，输出，high，表示发送器已经准备好了，这表示发送数据缓冲器空的（没空怎么发啊），CPU可以向8251A发送数据。如果用中断形式的话，这个TxRDY也可以做中断请求信号，如果是查询方式就不断查询它就完事了

    - TxE 发送空信号，输出，high，表示并串转化器为空（数据要经过并串转化器把并行数据转化成串行数据才能发送）。如果8251获得一个数据，TxE就为低。在同步方式下不允许字符串有间隔，但如果CPU来不及给8251A发送数据，则TxE就为1，插入同步字符

    - RxRDY，表示接受器准备好了，可以接受数据了，如果从外设接收到一个数据，等待CPU处理，当然也可以用中断了，把这个当成中断请求信号，程序查询就查他就完事了

    - SYNDET：同步检测信号（只用于同步方式）
    		同步检测/断电检测信号，高有效，输出/输入 同步方式时表示同步检测，如果为内同步，作为输出，输出为1，表示找到同步字了；在外同步的时候，作为输入，变高后，在RxC#（接收器时钟）的下一个下降沿装配字符，在异步方式下，作为空白检测信号，输出，如果接收到全0的字符，输出高电平
```

### 8251A与外设的连接信号

![3](IO.assets/3.png)

``` markdwon
数据信号
    - TXD
    发送数据信号TXD用来输出数据，CPU送往8251A的并行数据转换为串行数据后，通过TXD送往外设
    - RXD
    接收数据信号RXD用来接收外设送来的串行数据，数据进入8251A后，转换为并行方式

和外设的联络信号
    - DTR#  数据终端准备好了，由8251A发给外设，表示CPU准备就绪
    - DER#  数据设备请求好了，由外设发给8251A，表示外设已经准备就绪
    - RTS#  请求发送信号，由8251A发送给外设，表示CPU已经准备好发送
    - CTS#  清除请求发送信号，由外设发送8251A，表示可以往外设发送数据
    - CLK          8251A的内部时序时钟，同步要求是波特率的30倍，异步的话要求波特率的4.5倍
    - TxC，发送时钟，输入，控制字符的发送速度，同步是等于字符传送的波特率，异步方式是初始化定义的
    - RxC，和TxC差不多，是控制接受端的接受速度

时钟、电源、地
    - CLK：用来产生8251A器间的内部时序
    - TXC:发送器时钟输入，用来控制发送字符的速度
    - RXC:接收器时钟输入，用来控制接收字符的速度
    - VCC
    - GND
```
## 4.编程

![4](IO.assets/4.png)

### 8251A的初始化

8251A有一个奇一个偶两个端口地址；

``` markdown
偶地址端口对应数据输入寄存器和数据输出寄存器；
奇地址端口对应状态寄存器，模式寄存器，控制寄存器，同步字符寄存器
```

#### 用偶地址端口时(A1=0)
``` markdown
写入：数据输入寄存器
读出：数据输出寄存器
```

#### 用奇地址端口时（A1=1)(8251A初始化的约定)
``` markdown
第一种描述方法（来自课本）
    芯片复位以后，第一次用奇地址端口写入的值作为模式字送入模式寄存器
    如果模式字中规定了8251A工作在同步模式，那么，CPU接着往奇地址端口输出的就是同步字符，同步字符被写入同步字符寄存器。如此前规定同步字符为两个，则会按先后次序分别写入第一个同步字符寄存器和第二个同步字符寄存器
    此后，只要不是复位命令，不管是同步模式，还是异步模式，由CPU往奇地址端口写入的值都将作为控制字送到控制寄存器，而往偶地址端口写入的值将作为数据，送到数据发送缓冲器

第二种描述方法（来自网络）
    芯片复位之后，第一次用奇地址写控制字，在控制字中规定是同步还是异步；
    如果是同步方式，CPU会接着发1或者2个字节就是同步字符，写入同步字符寄存器，然后再把控制命令字写入奇端口；
    如果是异步方式，CPU往奇端口输出的一个字就是命令控制字；
    在相关命令设置好了之后，只要不复位，用奇端口写控制字，偶端口写的是数据，送到数据输出缓冲器中
```
####  地址说明
``` markdown
- 关于8位接口芯片和16位数据总线的连接问题
    - 8086CPU有一个必须遵守的约定，即低八位数据线总是与偶地址存储单元或端口关联；
    - 而高八位数据线总是与奇地址存储单元或端口关联；
    - 为了满足这一个要求，连接时在硬件上将总线的A1与8251A的C//D引脚相连接，而在软件设计的时候，用连续的偶地址代替端口的奇偶地址，就解决了8位接口芯片与16位数据总线的连接
```
#### 初始化的概述

``` markdown
- 模式字决定了8251A将工作在同步模式还是异步模式，如果工作在同步模式，还会指出同步字符的个数是一个还是两个；同步字符被写入同步字符寄存器
- 如果是异步模式，则在设置完模式字后，接着便要设置控制字
控制字的主要含义相同，控制字就是各种控制命令，包括复位命令
- CPU向8251A发送控制字之后，8251A首先判断控制字是否为复位命令：如果是复位命令，则返回重新接收模式字；如果不是复位命令，则8251A开始进行数据传输。
```
### 模式寄存器的格式

模式字**8位**

#### 异步模式

需要考虑的量：停止位/校验位/校验允许位/数据位的数目/波特率因子

![5](IO.assets/5.png)
``` markdown
（从高到低）
前两位是停止位的数目，00非法，01是1位，10是1.5位，11是2位停止位
第三位是EP（奇偶校验类型），0为奇校验，1为偶校验
第四位是有无校验，0是无，1是有
第五第六位是数据的大小，00是5位，01是6位，10是7位，11是8位
最后两位是决定波特率因子（不能是00，00就表示同步通信了），01表示波特率因子为1，10表示波特率因子为16，11表示波特率因子为64
举个例子，异步通信，1个停止位，无校验，8个数据位（刚好最近在做单片机的串口通信，这就是8N1格式）波特率因子为16，则应该向奇端口（假设还是FFF2H吧）写入01001110B，HEX格式为4EH、
- MOV DX,       FFFEH（端口地址）
- MOV AL, 4EH（模式字）
- OUT DX, AL


波特率
同步模式下，发送和接收的波特率分别和/TxC引脚，/RxC引脚上的输入时钟的频率相同
异步模式下，要用模式寄存器中的最低2位来确定波特率因子，
此时满足: /TxC引脚，/RxC引脚上的输入时钟的频率=波特率因子*波特率
```
#### 同步模式

需要考虑的量:同步字符的数目/同步方式/奇偶校验/奇偶校验允许位/数据位的数目/同步模式
![6](IO.assets/8.png)
``` markdown
（从高到低）
第一位是同步字符的位数，0是2个同步字符，1是1个同步字符
第二位决定是内同步还是外同步，0是内同步，1是外同步
第三位是奇偶校验位，0是奇校验，1是偶校验
第四位是有没有校验，0是没有校验，1是有校验
第五第六位是决定数据块的位数，00是5位，01是6位，10是7位，11是8位
最后两位必定是00
举个例子，比如说现在要求发送的是同步方式，1个同步字符外同步，偶校验，数据位是8位，那么初始化命令字就应该向奇端口（假如为FFF2H）写01111100B，换成16进制就是79H
汇编初始化就应该是
- MOV DX FFF2H
- MOV AL 79H
- OUT DX AL
````
### 控制寄存器的格式

![6](IO.assets/6.png)
``` markdown
从高到低
第七位：检索同步字符，只用在内同步模式，为1时，8251A会对同步字符进行检索
第六位：使8251A复位，从而重新进入初始化流程
第五位：用来设置发送请求，此位置为1会使得/RTS引脚输出为低电平
第四位：1将清楚状态寄存器中所有的出错指示位
第三位：为1使得引脚TxD变为低电平，于是输出一个空白字符
第二位：接收允许信号，在CPU从8251A接收数据前，先使此位为1
第一位：DTR
第零位：发送允许信号，只有将此位是1时，才能使数据从8251A接口往外设传输
```
### 状态寄存器的格式

![7](IO.assets/7.png)
``` markdown
当需要检测8251A的工作状态时，需要用到状态字。
状态字存放在状态寄存器中。
```

## 应用举例

### 异步模式下的初始化程序举例

设8251A工作在**异步模式**，波特率系数(因子)为16，7个数据位/字符，偶校验，2个停止位，发送、接收允许，设端口地址为0042H。完成初始化程序。
``` assembly
;- 模式字：1111010B->FAH
;- 控制字：00110111B->37H (?)
;- 端口地址:对于CPU来说是偶地址，对于接口是奇地址

;- 初始化：
MOV AL,0FAH;送模式字
OUT 42H,AL ;异步方式，7位字符，偶校验,2个停止位  
MOV AL,37H;设置控制字，使发送、接收允许，清出错标志，使 /RTS和/DTR有效 
OUT 42H,AL ;送控制字
```


### 同步模式下初始化程序举例 
- 设端口地址为42H，采用内同步方式，2个同步字符（设同步字符为16H），偶校验，7位数据位/字符 
``` assembly
;- 模式字00111000B 即38H
;- 控制字为：10010111B 即97H（？）。它使8251A对同步字符进行检索；同时使状态寄存器中的3个出错标志复位；此外，使8251A的发送器启动，接收器也启动；控制字还通知8251A，CPU当前已经准备好进行数据传输。 

;具体程序段如下：  
MOV AL，38H  ;设置模式字，同步模式，  用2个同步字符，
OUT 42H，AL   ; 7个数据位，偶校验
MOV AL，16H  
OUT 42H，AL   ;送同步字符16H
OUT 42H，AL    ;同步字符有两个一样的，因此送两次
MOV AL， 97H   ;设置控制字，使发送器和接收器启动
OUT 42H，AL
```
### 利用状态字进行编程的举例 

先对8251A进行初始化，然后对状态字进行测试，以便输入字符。本程序段用来输入80个字符。

分析：8251A的控制和状态端口地址为42H，数据输入和输出端口地址为40H。字符输入后，放在BUFFER标号所指的内存缓冲区中。
``` assembly
;具体的程序段如下：
    MOV AL,0FAH 
    OUT 42H,AL
    MOV AL,35H
    OUT 42H,AL
    MOV DI,0
    MOV CX,80
B：
    IN AL,42H
    TEST AL,02H
    JZ B  
    IN AL,40H
    MOV BX,OFFSET BUFFER
    MOV [BX+DI],AL
    INC DI
    IN AL,42H
    TEST AL,38H 
    JNZ E
    LOOP B
    JMP EXIT
E： 
    CALL ERR-OUT      
    EXIT:... ...
```


# Ⅳ、并行接口和并行芯片


- 并行通信就是把一个字符的各位用几条线同时进行传输；

-  ![10](IO.assets/10.png)

``` markdown
- 控制寄存器

	- - 用来接收CPU的控制命令

- 状态寄存器

	- - 提供各种状态位供CPU查询

- 输入缓冲寄存器

- 输出缓冲寄存器

```


# Ⅴ、8255A

可编程并行通信接口8255A

## 1.8255A的内部结构

![11](IO.assets/11.png)

### ①数据端口A,B,C

``` markdown
- Port A
    端口A具有一个8位数据输入锁存器和一个数据输出锁存器/缓冲器；
    用端口A做输入口或输出口时，数据均受到锁存

- Port B
    端口B具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器；

- Port C
    端口C具有一个8位数据输入缓冲器和一个数据输出锁存器/缓冲器，一般作为控制或状态信息端口
    当端口C作为输入口时，对数据不锁存
    当端口C作为输出口时，对数据进行锁存

使用中，A，B口为两个独立的数据输入输出端口，C口配合A口和B口的工作
C口常常通过控制命令被分成2个四位的端口，分别用来为端口A和B提供控制信号和状态信号
```

### ②A组控制和B组控制

``` markdown
控制端口A与端口C的高4位（PC7-PC4）
控制端口B与端口C的低4位（PC3-PC0）
```

### ③读/写控制逻辑电路

```markdown
功能：管理数据传输过程。

CS#-片选信号

A0、A1-端口选择信号

RD#-读信号

WR#-写信号

RESET-复位信号

读写控制逻辑：接收/CS信号以及来自地址总线的选择端口信号（A2 A1），还接收控制总线的信号/WR,/RD,REST，并将其组合成A和B组的控制信号
```


### ④数据总线缓冲器

```markdown
双向三态的8位数据缓冲器，8255A正是通过它与系统数据总线相连
```

## 2.芯片引脚信号

### 和外设相连的信号

```markdown
PA0－PA7：A口的8条输入输出信号线。
PB0－PB7：B口的8条输入输出信号线。
PC0－PC7：C口的8条输入输出信号线。
```

### 和CPU相连的信号


```markdown
D0－D7：双向数据信号线。和系统总线相连
/RD：读信号线。
/WR：写信号线。
/CS：片选信号线。当片选信号有效时，读信号和写信号才对8255A有效
A1、A0：口地址选择信号线。8255A有四个端口地址
00--A端口；01--B端口；10--C端口；11--控制口。
RESET：复位输入信号，复位时内部寄存器都被清除，同时，三个数据端口自动置为输入口
```

![12](IO.assets/12.jpg)

### 端口地址举例说明

![13](IO.assets/13.png)

## 3.控制字

控制字分为两类：各端口的方式选择控制字和C端口的按位置1/置0控制字

```markdown
控制字的D7位称为标识位
D7=1--->方式选择控制字的标识符
D7=0--->C端口的按位置1/置0控制字的标识符
```

### 方式选择控制字

方式选择控制字的格式

![](IO.assets/14.jpg)

说明

```markdown
8255A的[三种工作方式]
    方式0：基本的输入/输出方式
    方式1：选通的输入/输出方式
    方式2：双向传输方式

端口A可以工作在三种工作方式的任意一种，端口B只能工作在方式0或方式1，端口C则常配合端口A和B的工作，为这两个端口的输入/输出提供控制信号和状态信号
归为同一组的两个端口可以分别工作在输入或输出方式，不要求其工作同输入或输出
```



### 端口C置1/置0控制字

![15](IO.assets/15.jpg)

```markdown
○ 8255A的端口C的各位均可用置1/置0控制字单独设置，因此C端口很适合做控制位使用
○ 当8255A收到控制字时，就对最高位即标识位进行检测，D7=1，将此字节作为方式选择控制字写入控制寄存器，D7=0，将此字节作为端口C置1/置0控制字
○ C端口的按位置1/置0控制字注意：
    § C端口的按位置1/置0控制字尽管时对C端口进行操作，但必须写入控制端口，而不是写入C端口
    § D0位决定置1或置0 ，D0=0置0; D0=1置1
    § D3、D2、D1位决定了对C端口中的哪一位操作 
    § D4 5 6无影响
    § D7位必须为0 
```



## 4.工作方式

```
方式0：基本输入输出方式	适用于无条件传送和查询方式的接口电路（传输方式转8086页面）
方式1：选通输入输出方式	适用于查询和中断方式的接口电路
方式2：双向选通传送方式	适用于双向传送数据的外设	适用于查询和中断方式的接口电路
```

### ①方式0

基本的输入/输出方式

#### 特点

```
- PA和PB可通过方式选择控制字规定为输入或者输出端口- PC分为两个四位端口，高四位一个端口，第四位一个端口；这两个四位端口，也可以通过方式选择控制字规定为输入或输出端口端口可作为输入口，也可作为输出口，各端口之间没有规定必然的联系。可以有16种不同的组合，适用于多种不同的场合。 
```

#### 时序

输入（CPU从8255A读取数据）时序要求

```
发出读信号前，先发出地址信号，从而使得8255A的片选信号和端口选择信号A1         A0有效，于是启动8255A输入数据要领先于读信号（要求在CPU发出读信号之前，外设已经将数据送到8255A的输入缓冲器中） 
```

输出（将数据有效传输到8255A）时序要求

```
略
```

#### 应用

```
用于连接简单外设。适用于：（1）无条件输入输出方式。（2）查询输入输出方式：A、B口作为8位数据的输入或输出口，C口的高/低4位分别定义为A、B口的控制位和状态  位，作为A（B）的应答信号。应答信号不固定，可自由定义应用实例：作为主机和打印机的接口
```



### ②方式1

选通的输入/输出方式

#### 特点

```
- PA和PB用方式1进行输入/输出，端口C自动提供选通信号和应答信号- PA和PB端口只有一个工作在方式1，那么PC一个端口中有3位被规定为配合方式1工作的信号，PC的另一个端口可以工作在方式0，PC的其他位以可工作在方式0，即作为输入/输出- PA和PB都工作在方式1，那么PC中就需要6位用来作为配合方式1工作的信号，剩下的两位可以作为输入和输出
```

#### 时序

输入信号和输入时序

 ![16](IO.assets/16.jpg)

输出信号和输出时序

 ![17](IO.assets/17.jpg)

#### 应用

```markdown

```



### ③方式2
双向传输方式

#### 特点

```
方式2将方式1的选通输入输出功能组合成一个双向数据端口，可以发送数据和接收数据；只有端口A可以工作于方式2，需要利用端口C的5个信号线，其作用与方式1相同；方式2的数据输入过程与方式1的输入方式一样；方式2的数据输出过程与方式1的输出方式有一点不同：数据输出时8255A不是在OBF#有效时向外设输出数据，而是在外设提供响应信号ACK#时才送出数据
```

#### 时序

![18](IO.assets/18.png)

``` 
略
```
#### 应用

```
磁盘驱动器
```



## 5.应用举例

